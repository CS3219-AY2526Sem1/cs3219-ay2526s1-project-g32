version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  rabbitmq:
    image: rabbitmq:3-management
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    ports:
      - "5672:5672"
      - "15672:15672"
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
  user:
    build: ./user_service
    env_file:
      - ./user_service/.env
    ports:
      - "4001:4001"
    healthcheck:
      test: ["CMD-SHELL", "node -e 'const http=require(\"http\");http.get(\"http://localhost:4001/\",r=>process.exit(r.statusCode>=200&&r.statusCode<400?0:1))'" ]
      interval: 30s
      timeout: 5s
      retries: 3

  question:
    build: ./question_service
    env_file:
      - ./question_service/.env
    ports:
      - "4003:4003"
    healthcheck:
      test: ["CMD-SHELL", "node -e 'const http=require(\"http\");http.get(\"http://localhost:4003/health\",r=>process.exit(r.statusCode>=200&&r.statusCode<400?0:1))'" ]
      interval: 30s
      timeout: 5s
      retries: 3

  matching:
    build: ./matching_service
    ports:
      - "3002:3002"
    depends_on:
      rabbitmq:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - RABBITMQ_URL=amqp://rabbitmq:5672
      - REDIS_URL=redis://redis:6379
      - USER_SERVICE_URL=http://user:4001
      - COLLABORATION_SERVICE_URL=http://collaboration:4010/api/v1/sessions
    healthcheck:
      test: ["CMD-SHELL", "node -e 'const http=require(\"http\");http.get(\"http://localhost:3002/\",r=>process.exit(r.statusCode>=200&&r.statusCode<400?0:1))'" ]
      interval: 30s
      timeout: 5s
      retries: 3

  collaboration:
    build: ./collaboration_service
    env_file:
      - ./collaboration_service/.env
    ports:
      - "4010:4010"
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      redis:
        condition: service_healthy
      question:
        condition: service_started
      user:
        condition: service_started
    healthcheck:
      test: ["CMD-SHELL", "node -e 'const http=require(\"http\");http.get(\"http://localhost:4010/\",r=>process.exit(r.statusCode>=200&&r.statusCode<400?0:1))'" ]
      interval: 30s
      timeout: 5s
      retries: 3

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - PORT=3000
      - NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL:-http://user:4001}
      # Provide explicit service hostnames so the frontend inside Docker can reach backend services by default.
      - NEXT_PUBLIC_USER_SERVICE_URL=${NEXT_PUBLIC_USER_SERVICE_URL:-http://user:4001/api/v1}
      - NEXT_PUBLIC_MATCHING_SERVICE_URL=${NEXT_PUBLIC_MATCHING_SERVICE_URL:-http://matching:3002/api/v1/matching}
    depends_on:
      - user
      - collaboration
      - matching
      - question
    healthcheck:
      test: ["CMD-SHELL", "node -e 'const http=require(\"http\");http.get(\"http://localhost:3000/\",r=>process.exit(r.statusCode>=200&&r.statusCode<400?0:1))'" ]
      interval: 30s
      timeout: 5s
      retries: 3

volumes:
  collaboration_node_modules: {}
  user_node_modules: {}
  matching_node_modules: {}
  question_node_modules: {}
  frontend_node_modules: {}
  # (volumes for node_modules are declared in docker-compose.override.yml, where they are used)
